### Сделать папку репозиторием — в bash, находясь в директории с проектом вводим команду `git init` Создастся директория .git в которой будет храниться вся служебная информация.
### «Разгитить» папку, если что-то пошло не так, — в bash, находясь в директории с проектом вводим команду `rm -rf .git` Удалится директория .git со всей служебной информацией.
### Проверить состояние репозитория — `git status`Выведет на экран текущее состояние репозитория:
- название текущей ветки: `On branch master` или `On branch main`
- сообщение о том, что в репозитории ещё нет коммитов: `No commits yet`
- сообщение, которое говорит: «чтобы что-нибудь закоммитить (то есть зафиксировать), нужно сначала это создать» — `nothing to commit (create/copy files and use "git add" to track)`

### Создать файл — `touch todo.txt` Создаст файл в выбранной директории.
### Подготовить файлы к сохранению — 
- `git add -all` подготовить к сохранению все файлы в репозитории
- `git add .` подготовить к сохранению всю текущую папку
### Выполнить коммит — `git commit -m "message"` Сохранит текущую версию файлов в репозитории с введенным сообщением. Выведет информацию о коммите на экран.
`[master (root-commit) 5bcba49] Message`:
- коммит был в ветке `master`
- `root-commit` — это самый первый, или «корневой» (англ. _root_), коммит в ветке, у следующих коммитов такой надписи не будет
- `5bcba49` — сокращённый идентификатор коммита
`2 files changed, 6 insertions(+)`:
- изменились два файла
- шесть строк было добавлено
`create mode 100644 todo.txt:`
- `create` (англ. «создать») говорит, что файл был создан
- `mode 100644` сообщает, что это обычный файл. Также возможны варианты `100755` для исполняемых файлов (например, `что-нибудь.exe`) и `120000` для файлов-ссылок в Linux
### Просмотреть историю коммитов — `git log` Выведет историю коммитов: Идентификатор коммита, его автор и дата создания, сообщение.

Git:
- консольный инструмент для работы с локальными и удалёнными репозиториями
- проект с открытым исходным кодом.
GitHub:
- платформа для размещения удалённых репозиториев
- принадлежит компании Microsoft
- 
Сетевой протокол — **SSH** (от англ. _**S**ecure **Sh**ell Protocol_). Он обеспечивает безопасный обмен данными в сети. С помощью этого протокола можно получать данные с удалённого компьютера или отправлять их на него. Трафик шифруется, поэтому протокол безопасен.

SSH использует пару ключей для обеспечения безопасности — публичный и приватный:
- **Приватный ключ** (англ. _private key_) хранится только на вашем компьютере и не должен передаваться кому-либо ещё. Он используется для расшифровки данных.
- **Публичный ключ** (англ. _public key_) доступен всем и используется для шифрования данных. Они могут быть расшифрованы парным приватным ключом.

### Проверка наличия SSH-ключа:
 - `cd ~` # перешли в домашнюю директорию
 - `ls -la .ssh/` # вывели список созданных ключей
 - Если папка пустая или её нет, всё в порядке.
 - Если есть файлы с похожими названиями, SSH-ключи уже создавались:
	- `id_dsa.pub`;
	- `id_ecdsa.pub`;
	- `id_ed25519.pub`;
	- `id_rsa.pub`.
- Если вы не создавали эти файлы, удалите их все.
 ### Инструкция по генерации SSH-ключа:
 - Введите команду`ssh-keygen -t ed25519 -C "mendelev.work@gmail.com"`Используйте электронную почту, к которой привязан ваш GitHub-аккаунт.
 - После ввода отобразится такое сообщение. `Generating public/private rsa key pair.` # сгенерированы публичный и приватный ключи.
 - Программа запросит **кодовую фразу** (англ. _passphrase_) для доступа к SSH-ключу. Вы можете оставить поле пустым. Для этого нажмите `Enter`, а затем ещё раз `Enter` для подтверждения.
 - Проверить, что ключи действительно сгенерировались. Для этого вызовите эту команду `ls -a ~/.ssh`
# Привязываем SSH-ключ к GitHub:
После выполнения команды `ssh-keygen` из предыдущей инструкции в директории `~/.ssh` будет создано два файла — `id_ed25519` и `id_ed25519.pub`:
- `id_ed25519`/`id_rsa` — приватный ключ (файл без `.pub` в конце). Ни в коем случае не копируйте его и не делитесь им.
- `id_ed25519.pub`/`id_rsa.pub` — публичный ключ (на это указывает расширение `.pub`).
1. Скопируйте содержимое файла с публичным ключом в буфер обмена — `clip < ~/.ssh/id_ed25519.pub`
2. Перейдите на GitHub и выберите пункт **Settings** (англ. «настройки») в меню аккаунта.
3. В меню слева нажмите на пункт **SSH and GPG keys**.
4. В открывшейся вкладке выберите **New SSH key** (англ. «новый SSH-ключ»).
5. В поле **Title** (англ. «заголовок») напишите название ключа. Например, **Personal key** (англ. «личный ключ»).
6. В поле **Key type** (англ. «тип ключа») должно быть **Authentication Key** (англ. «ключ аутентификации»).
7. В поле **Key** скопируйте ваш ключ из буфера обмена.
8. Нажмите на кнопку **Add SSH key** (англ. «добавить SSH-ключ»).
9. 9. Проверьте правильность ключа с помощью следующей команды —  `ssh -T git@github.com
10. Если это первый раз, когда вы используете Git, чтобы поделиться проектом на GitHub, появится предупреждение: `The authenticity of host 'github.com (140.82.121.4)' can't be established. ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU. This key is not known by any other names. Are you sure you want to continue connecting (yes/no/[fingerprint])?` Это предупреждение сообщает, что вы никогда не соединялись с сервером GitHub. Поэтому Git не может гарантировать, что сервер является тем, за кого он себя выдаёт. Введите `yes`, чтобы продолжить. Вы увидите приветствие на экране. `Hi %ВАШ_АККАУНТ%! You've successfully authenticated, but GitHub does not provide shell access.`
### Привязать удалённый репозиторий к локальному — Перейдите на страницу удалённого репозитория, выберите тип `SSH` и скопируйте URL. Кнопка справа позволит сделать это мгновенно`git remote add origin SSH`
`git remote add origin https://github.com/DZMITRY1998/Git_project.git`

В командную строку нельзя вставить текст из буфера обмена с помощью привычного сочетания `Ctrl+V`. На Windows (в Git Bash) и Linux для этого используется сочетание `Ctrl+Shift+V`.

### Убедиться, что репозитории связаны — c помощью команды `git remote -v`, которая выведет:
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push)

### Отправить изменения на удалённый репозиторий — `git push`
В первый раз эту команду нужно вызвать с флагом `-u` и параметрами `origin` (имя удалённого репозитория) и `main` или `master` (название текущей ветки). Флаг `-u` свяжет локальную ветку с одноимённой удалённой. Как вы связывали локальный и удалённый репозитории в предыдущем действии, так же и здесь нужно дополнительно связать ветки.
`git push -u origin main` # Если команда приведёт к ошибке, попробуйте заменить main на master. Появится такой экран.
![[Pasted image 20240803171555.png]]
# Файл README.md и зачем он нужен
Как правило, в `README.md` проекта можно найти следующую информацию:

1. Название проекта и его краткое описание: кем создан, для чего, какие решает задачи и какие закрывает проблемы.
2. Технологии, которые применяются в проекте. В чём его отличие от аналогичных.
3. Документация проекта — подробная инструкция о том, что представляет собой проект.
4. Планы проекта, если они есть.
Преимущество `README.md` в том, что средства командной работы (такие, как GitHub) могут отображать его содержимое в браузере в виде удобной разметки. Для этого нужно не просто залить текст, но и настроить шрифт, заголовки и отступы с помощью markdown. **Маркда́ун** — это специальный язык разметки. Он позволяет красиво отформатировать текстовый документ.
Разберём базовый синтаксис этого языка. Все правила запоминать не нужно: при оформлении репозитория вы всегда можете вернуться к этому уроку.
### Заголовки, абзацы и перенос

- **Заголовки** разных уровней создают решётками.

```
# H1 — заголовок первого уровня, самый большой
## H2 — заголовок второго уровня, поменьше
### H3
#### H4
##### H5
###### H6 — заголовок шестого уровня, самый маленький 
```

- Можно добавить **черту под заголовком или абзацем**.

```
#### Заголовок 4

Текст над чертой

---

Текст под чертой 
```

- Чтобы сделать **разрыв строки**, нужно поставить два пробела (в примере ниже они обозначены точками `⋅⋅`) или сочетание символов `<br>`.

```

Текст до переноса⋅⋅  
Текст после переноса <br>
Текст после второго переноса 
```

- Чтобы начать **новый параграф**, в конце предыдущей строки должно стоять два символа переноса. Для этого нужно нажать `Enter` два раза.

```
line

another line  
```

Если сделать один перенос строки, как в примере ниже, и не поставить два пробела, текст сольётся в одну строку.

```
line 
another line 
```

Вот пример текста в файле `README.md`.

![](https://pictures.s3.yandex.net/resources/M2_T4_01-3_1685964240.png)

А вот отображение такого файла.

![](https://pictures.s3.yandex.net/resources/M2_T4_02-3_1685964252.png)

### Выделение текста

- Чтобы выделить текст **курсивом** (`*текст*`), его заключают в звёздочки (астериски) или нижние подчёркивания.

```
Курсив — это *звёздочки* или _подчёркивания_. 
```

- Чтобы выделить текст **полужирным шрифтом** (`**текст**`), его окружают двойными звёздочками или двойными нижними подчёркиваниями.

```
Полужирный шрифт — двойные **звёздочки** или двойные __подчёркивания__.
Можно совместить выделение **звёздочки и _подчёркивания_**. 
```

- Чтобы **зачеркнуть текст** (`~~текст~~`), его окружают двойными волнистыми линиями — тильдами.

```
~~Зачёркнутый текст.~~ 
```

### Списки

- Для оформления **нумерованного списка** достаточно поставить в начало строки цифры с точкой.


```
1. Первый пункт нумерованного списка.
2. Второй пункт. 
```

- **Ненумерованный список** создаётся звёздочкой с пробелом в начале строки либо дефисом с пробелом.

```
* первый пункт ненумерованного списка;
* второй пункт ненумерованного списка

- первый пункт ненумерованного списка;
- второй пункт ненумерованного списка 
```

### **Ссылки**

- Чтобы сделать ссылкой часть текста, его заключают в квадратные скобки, а затем указывают нужный адрес в круглых скобках.

```
[Яндекс](https://www.yandex.ru) 
```

- Также можно добавить ссылке **тайтл** (от англ _title_ — «название», «заголовок»). Тайтл — это всплывающая подсказка, которая появляется при наведении мыши на ссылку. Тайтл нужно заключить в кавычки и указать внутри скобок после адреса.

```
[Яндекс](https://www.yandex.ru "Я Yandex!") 
```

### **Код**

Чтобы оформить текст как код, нужно окружить его тройками косых кавычек — грависов. После первой тройки грависов указывают язык программирования, на котором написан код. В маркдауне есть поддержка синтаксиса почти всех популярных языков и инструментов.

````
```bash
ls - la
```
```html
<h1>А я просто текст</h1>
``` 
````

Обратите внимание: вторая тройка тройных кавычек стоит на отдельной строке.

## Пример файла `README.md`

Если собрать всё вместе, файл `README.md` может выглядеть так.

````
# Шпаргалка markdown

## Выделение текста

Вы можете выделять текст в markdown с помощью символов `_` или `*`. Например:

Пример _курсива_ и **жирного** текста.

## Заголовки

Заголовки можно создавать с помощью символа `#`. Чем больше `#`, тем меньше заголовок. Например:

# Заголовок первого уровня
## Заголовок второго уровня
### Заголовок третьего уровня

## Выделение кода

Чтобы выделить текст как код, поместите его в тройные кавычки `````. 

```
mkdir my_project
cd my_project
git init
```
Это лишь некоторые функции markdown. 
````

А вот так этот файл будет встречать гостей репозитория.

![](https://pictures.s3.yandex.net/resources/M2_T4_03_1685964697.png)

# Хеш — идентификатор коммита
**Хеширование** (от англ. _hash_, «рубить», «крошить», «мешанина») — это способ преобразовать набор данных и получить их «отпечаток» (англ. _fingerprint_).

Информация о коммите — это набор данных: когда был сделан коммит, содержимое файлов в репозитории на момент коммита и ссылка на предыдущий, или **родительский** (англ. _parent_), коммит.

Git хеширует (преобразует) информацию о коммите с помощью алгоритма **SHA-1** (от англ. _**S**ecure **H**ash **A**lgorithm_ — «безопасный алгоритм хеширования») и получает для каждого коммита свой уникальный **хеш** — результат хеширования.

Обычно хеш — это короткая (4040 символов в случае SHA-1) строка, которая состоит из цифр 0—90—9 и латинских букв A—FA—F (неважно, заглавных или строчных). Она обладает следующими важными свойствами:

- если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;
- если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).

После вызова `git log` появляется список коммитов. Разберём элементы, из которых состоит описание:

- строка из цифр и латинских букв после слова **commit** — это хеш коммита;
- **Author** — имя автора и его электронная почта;
- **Date** — дата и время создания коммита;
- в конце находится сообщение коммита.

### Получить сокращённый лог — `git log --oneline` В терминале появятся только первые несколько символов хеша каждого коммита и их комментарии.
Обратите внимание: если выход из просмотра логов не произошёл автоматически, нажмите клавишу `Q` (от англ. _**Q**uit —_ «выйти») в английской раскладке клавиатуры.

### Файл `HEAD`
Файл `HEAD` (англ. «голова», «головной») — один из служебных файлов папки `.git`. Он указывает на коммит, который сделан последним (то есть на самый новый). Если заглянуть в этот файл, можно увидеть хеш последнего коммита.

### Статусы `untracked`/`tracked`, `staged` и `modified`

Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом. Рассмотрим основные.

- **`untracked`** (англ. «неотслеживаемый»)  
    Мы говорили, что новые файлы в Git-репозитории помечаются как `untracked`, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У `untracked`-файла нет предыдущих версий, зафиксированных в коммитах или через команду `git add`.
- **`staged`** (англ. «подготовленный»)
    
    После выполнения команды `git add` файл попадает в **staging area** (от англ. _stage_ — «сцена», «этап [процесса]» и _area_ — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии `staged`.
    
    В одном из предыдущих уроков мы сравнили коммит с фотографией. Можно развить эту аналогию и сказать, что команда `git add` добавляет персонажей (текущее содержимое файла или нескольких файлов) на **сцену** (англ. _stage_) для общей фотографии, а `git commit` делает снимок всей сцены целиком.
    
    💡 **Staging area, index и cache**
    
    Staging area также называют **index** (англ. «каталог») или **cache** (англ. «кеш»), а состояние файла `staged` иногда называют `indexed` или `cached`.
    
- **`tracked`** (англ. «отслеживаемый»)  
    Состояние `tracked` — это противоположность `untracked`. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью `git commit`, а также файлы, которые были добавлены в staging area командой `git add`. То есть все файлы, в которых Git так или иначе отслеживает изменения.
- **`modified`** (англ. «изменённый»)  
    Состояние `modified` означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

# Оформление сообщений к коммитам

**Инфинитив и императив**

Для сообщений на русском языке часто рекомендуют использовать инфинитивы. Например: `Добавить тесты для PipkaService`, `Исправить ошибку #123` и так далее.

Для сообщений на английском рекомендуется использовать **повелительное наклонение** (англ. _imperative_). Например: `Use library mega_lib_300`, `Fix exit button` и так далее.